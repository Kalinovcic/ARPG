import "imports.aspel";

window: glfw3.GLFWwindow^;
windowFullscreen: bool;

errorCallback :: func void(error: int32, desc: int8^)
{
    reportString(nullstrToString(desc));
    asl.exit(1);
}

keyCallback :: func void(window: glfw3.GLFWwindow^, key: int32, scancode: int32,
                         action: int32, mods: int32)
{
    if action != glfw3.GLFW_REPEAT
    {
        press := action == glfw3.GLFW_PRESS;
        shift := (mods & glfw3.GLFW_MOD_SHIFT) != 0;
        handleKeyInput(key, press, shift);
    }
}

// TODO: Focus listener. Require mouse click to get back in focus.
// TODO: Mouse button listener.

mouseButtonCallback :: func void(window: glfw3.GLFWwindow^, button: int32,
                                 action: int32, mods: int32)
{
    press := action == glfw3.GLFW_PRESS;
    shift := (mods & glfw3.GLFW_MOD_SHIFT) != 0;
    handleMouseInput(button, press, shift);
}

mouseMotionCallback :: func void(window: glfw3.GLFWwindow^, xpos: float64, ypos: float64)
{
    handleMotionInput(cast(float32) xpos, cast(float32) ypos);
}

openWindow :: func void()
{
    glfw3.glfwSetErrorCallback(errorCallback);

    if glfw3.glfwInit() != gl.GL_TRUE
    {
        reportString("Failed to init GLFW.\n");
        asl.exit(1);
    }

    windowFullscreen = false;
    window = glfw3.glfwCreateWindow(960, 540, "ARPG\0", null, null);
    if window == 0
    {
        reportString("Failed to open GLFW window.\n");
        glfw3.glfwTerminate();
        asl.exit(1);
    }

    setupWindow();
}

toggleFullscreen :: func void()
{
    windowFullscreen = !windowFullscreen;

    newWindow: glfw3.GLFWwindow^;
    if windowFullscreen
    {
        primaryMonitor := glfw3.glfwGetPrimaryMonitor();
        newWindow = glfw3.glfwCreateWindow(1920, 1080, "ARPG\0", primaryMonitor, window);
    }
    else
    {
        newWindow = glfw3.glfwCreateWindow(960, 540, "ARPG\0", null, window);
    }

    if newWindow == 0
    {
        reportString("Failed to open GLFW window.\n");
        glfw3.glfwTerminate();
        asl.exit(1);
    }

    glfw3.glfwDestroyWindow(window);
    window = newWindow;

    setupWindow();
    clearInputState();
}

setupWindow :: func void()
{
    glfw3.glfwMakeContextCurrent(window);
    glfw3.glfwSwapInterval(1);
    glfw3.glfwSetKeyCallback(window, keyCallback);
    glfw3.glfwSetCursorPosCallback(window, mouseMotionCallback);
    glfw3.glfwSetMouseButtonCallback(window, mouseButtonCallback);

    initGL();
}

closeWindow :: func void()
{
    glfw3.glfwDestroyWindow(window);
    glfw3.glfwTerminate();
}

initGL :: func void()
{
    gl.glClearColor(1.0, 0.0, 1.0, 1.0);

    gl.glEnable(gl.GL_TEXTURE_2D);
    gl.glEnable(gl.GL_BLEND);
    gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA);
}

renderLoop :: func void()
{
    gameInit();

    targetFPS :: 60;
    frameTime: uint64 : cast(uint64)(1000000000.0 / targetFPS);

    lastTime := asl.timenanos();

    while glfw3.glfwWindowShouldClose(window) != gl.GL_TRUE
    {
        currentTime := asl.timenanos();
        deltaTime := currentTime - lastTime;

        width: int32;
        height: int32;
        glfw3.glfwGetFramebufferSize(window, &width, &height);

        setCameraViewport(width, height);

        ticked: bool = false;
        while deltaTime >= frameTime
        {
            processInput();
            gameTick();
            updateInput();

            ticked = true;

            lastTime = lastTime + frameTime;
            deltaTime = deltaTime - frameTime;
        }

        if ticked
        {
            gl.glClear(gl.GL_COLOR_BUFFER_BIT);
            gl.glMatrixMode(gl.GL_MODELVIEW);
            gl.glLoadIdentity();

            gameRender();

            glfw3.glfwSwapBuffers(window);
            glfw3.glfwPollEvents();
        }
    }
}

main :: func void(args: asl.string[])
{
    openWindow();
    renderLoop();
    closeWindow();
}
