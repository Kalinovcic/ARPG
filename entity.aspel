import "imports.aspel";

Entity :: type struct
{
    x: float32;
    y: float32;
    w: float32;
    h: float32;
    animation: Animation;

    health: float32;
    maxHealth: float32;
    mana: float32;
    maxMana: float32;

    userdata: int32;
    tick: delegate void(world: void^, entity: Entity^);
    render: delegate void(entity: Entity^);
};

partialEntityCollideWithTerrain :: func bool(terrain: Terrain^, entity: Entity^,
                                             moveX: float32^, moveY: float32^)
{
    // TODO: improve

    tw := terrain.w;
    th := terrain.h;

    x := entity.x;
    y := entity.y;
    mx := ^moveX;
    my := ^moveY;
    tx := cast(int32) x;
    ty := cast(int32) y;
    t := getTile(terrain, tx, ty);

    nx := x + mx;
    ny := y + my;

    nxo := nx + entity.w;
    nyo := ny + entity.h;

    ntx := cast(int32) nx;
    nty := cast(int32) ny;
    ntxo := cast(int32) nxo;
    ntyo := cast(int32) nyo;

    tiy := nty;
    while tiy <= ntyo
    {
        if tiy < 0 || tiy >= th then
            return false;

        tix := ntx;
        while tix <= ntxo
        {
            if tix < 0 || tix >= tw then
                return false;

            nt := getTile(terrain, tix, tiy);
            if t != nt then
                return false;

            tix = tix + 1;
        }

        tiy = tiy + 1;
    }

    return true;
}

entityCollideWithTerrain :: func void(terrain: Terrain^, entity: Entity^,
                                      moveX: float32^, moveY: float32^)
{
    fake: float32 = 0;
    if !partialEntityCollideWithTerrain(terrain, entity, moveX, &fake) then ^moveX = 0;
    if !partialEntityCollideWithTerrain(terrain, entity, &fake, moveY) then ^moveY = 0;
}

// OPTIMIZE: Quad tree, maybe?
projectileCollideWithEntities :: func int32(world: World^, projectile: Projectile^,
                                            result: Entity^[])
{
    resultCount: int32 = 0;
    if result.n <= resultCount then
        return resultCount;

    x := projectile.x;
    y := projectile.y;
    r := projectile.radius;

    i := 0;
    while i < world.entityList.n
    {
        i = i + 1;
        if !world.entityOccupied[i - 1] then continue;
        entity := &world.entityList[i - 1];

        ew := entity.w;
        eh := entity.h;
        ehw := entity.w / 2.0;
        ehh := entity.h / 2.0;
        ex := entity.x + ehw;
        ey := entity.y + ehh;

        dx := cast(float32) asl.abs(x - ex);
        dy := cast(float32) asl.abs(y - ey);

        if dx > (ehw + r) then continue;
        if dy > (ehh + r) then continue;

        if dx <= ehw {}
        else if dy >= ehh {}
        else if ((dx - ehw) * (dx - ehw) + (dy - ehh) * (dy - ehh)) <= r * r {}
        else continue;

        result[resultCount] = entity;
        resultCount = resultCount + 1;
        if result.n <= resultCount then
            return resultCount;
    }

    return resultCount;
}

entityTakeDamage :: func void(world: World^, e: Entity^, dmg: float32)
{
    e.health = e.health - dmg;
    if e.health < 0.0
    {
        removeEntityFromWorld(world, e);
    }
}

renderEntity :: func void(e: Entity^)
{
    renderAnimation(&e.animation, e.x, e.y, e.w, e.h, 0.0);
}

initPlayer :: func void(player: Entity^, posX: float32, posY: float32)
{
    player.x = posX;
    player.y = posY;
    player.w = 0.8;
    player.h = 0.8;
    player.animation = art.invalidAnimation;

    player.health = 322;
    player.maxHealth = 400;
    player.mana = 124;
    player.maxMana = 150;

    player.tick = tickPlayer;
    player.render = renderPlayer;
}

initEye :: func void(eye: Entity^, posX: float32, posY: float32)
{
    random: asl.Random;
    asl.seedRandomTime(&random);
    
    seed: int16 = cast(int16) (asl.randomInt32(&random) & 0xFFFF);
    tick: int16 = 0;

    eye.x = posX;
    eye.y = posY;
    eye.w = 2.0;
    eye.h = 2.0;
    eye.animation = art.eyeAnimation;
    eye.animation.tick = cast(int32)(cast(uint32) asl.randomInt32(&random) %
                                     cast(uint32)(eye.animation.frameTime *
                                                  eye.animation.frames.n));
    eye.animation.slowTick = cast(int32)(cast(uint32) asl.randomInt32(&random) %
                                         cast(uint32)(eye.animation.slowFrameFreq +
                                                      eye.animation.slowFrameTime *
                                                      eye.animation.slowFrames.n));

    eye.health = 100;
    eye.maxHealth = 100;
    eye.mana = 0;
    eye.maxMana = 0;

    eye.userdata = (cast(int32)(seed) << 16) | (cast(int32) tick);
    eye.tick = tickEye;
    eye.render = renderEntity;
}

tickPlayer :: func void(worldV: void^, player: Entity^)
{
    world: World^ = cast(World^) worldV;

    // TODO: Diagonal is faster.

    movementSpeed :: 0.05;

    mx := 0;
    my := 0;
    if input.key[INPUT_KEY_LEFT]  then mx = mx - 1;
    if input.key[INPUT_KEY_RIGHT] then mx = mx + 1;
    if input.key[INPUT_KEY_DOWN]  then my = my - 1;
    if input.key[INPUT_KEY_UP]    then my = my + 1;

    player.health = player.health + 0.02;
    if player.health > player.maxHealth then
        player.health = player.maxHealth;

    player.mana = player.mana + 0.02;
    if player.mana > player.maxMana then
        player.mana = player.maxMana;

    if (input.key[INPUT_KEY_LMB] && !prevInput.key[INPUT_KEY_LMB]) && player.mana >= 2.5
    {
        player.mana = player.mana - 2.5;

        random: asl.Random;
        asl.seedRandomTime(&random);

        mouseAngle := asl.atan2(-input.mouseX, -input.mouseY);

        projectile := addProjectileToWorld(world);
        projectile.x = player.x + player.w / 2.0 - 0.15;
        projectile.y = player.y + player.h / 2.0 - 0.15;
        projectile.z = 0;

        projectile.a = asl.to_degrees(mouseAngle);
        projectile.speed = 0.05;
        projectile.owner = player;
        projectile.damage = 8;

        projectile.radius = 0.15;
        projectile.lifetime = 400;
        projectile.animation = art.projectileAnimation;
        projectile.animation.tick = cast(int32)(cast(uint32) asl.randomInt32(&random) %
                                         cast(uint32)(projectile.animation.frameTime *
                                                      projectile.animation.frames.n));
    }

    moveX: float32 = cast(float32) mx * movementSpeed;
    moveY: float32 = cast(float32) my * movementSpeed;

    if !input.key[INPUT_KEY_MACRO4] then
        entityCollideWithTerrain(&world.terrain, player, &moveX, &moveY);
    // TODO: collide with other entitites

    player.x = player.x + moveX;
    player.y = player.y + moveY;

    walk: int32 = 0;
    if mx != 0 || my != 0 then walk = 1;

    prevWalk: int32 = player.userdata & 0x1;
    if walk == 0
    {
        if walk != prevWalk
        {
            player.userdata = player.userdata & ~0x1;
        }
    }
    else
    {
        player.userdata = (player.userdata & 0xFF00) | ((mx + 1) << 4) | ((my + 1) << 1) | 0x1;
    }
}

tickEye :: func void(worldV: void^, eye: Entity^)
{
    world: World^ = cast(World^) worldV;

    // TODO: Diagonal is faster.

    seed: int16 = cast(int16)(eye.userdata >> 16);
    tick: int16 = cast(int16)(eye.userdata & 0xFFFF);
    if tick >= 80
    {
        tick = 0;
        seed = seed + 1;
    }
    tick = tick + 1;
    eye.userdata = (cast(int32)(seed) << 16) | (cast(int32) tick);
    
    random: asl.Random;
    asl.seedRandom(&random, seed);

    movementSpeed :: 0.01;
    mx: float32 = cast(float32) (cast(uint32) asl.randomInt32(&random) % cast(uint32) 3) - 1.0;
    my: float32 = cast(float32) (cast(uint32) asl.randomInt32(&random) % cast(uint32) 3) - 1.0;
    moveX: float32 = mx * movementSpeed;
    moveY: float32 = my * movementSpeed;

    entityCollideWithTerrain(&world.terrain, eye, &moveX, &moveY);
    // TODO: collide with other entitites

    eye.x = eye.x + moveX;
    eye.y = eye.y + moveY;
}

renderPlayer :: func void(player: Entity^)
{
    userdata := player.userdata;
    mx := ((userdata >> 4) & 0x3) - 1;
    my := ((userdata >> 1) & 0x3) - 1;
    walk := userdata & 0x1;
    tick := (userdata & 0xFF00) >> 8;

    player.userdata = (userdata & ~0xFF00) | ((tick + 1) << 8);

    eyesAnimP: Animation^ = &art.invalidAnimation;
    hairAnimP: Animation^ = &art.invalidAnimation;
    skinAnimP: Animation^ = &art.invalidAnimation;
    bodyAnimP: Animation^ = &art.invalidAnimation;
    flipX: bool = false;

    if my < 0
    {
        if walk == 0
        {
            eyesAnimP = &art.playerEyesRestDownAnimation;
            hairAnimP = &art.playerHairRestDownAnimation;
            skinAnimP = &art.playerSkinRestDownAnimation;
            bodyAnimP = &art.playerBodyRestDownAnimation;
        }
        else
        {
            eyesAnimP = &art.playerEyesWalkDownAnimation;
            hairAnimP = &art.playerHairWalkDownAnimation;
            skinAnimP = &art.playerSkinWalkDownAnimation;
            bodyAnimP = &art.playerBodyWalkDownAnimation;
        }
    }
    else if my > 0
    {
        if walk == 0
        {
            eyesAnimP = &art.playerEyesRestUpAnimation;
            hairAnimP = &art.playerHairRestUpAnimation;
            skinAnimP = &art.playerSkinRestUpAnimation;
            bodyAnimP = &art.playerBodyRestUpAnimation;
        }
        else
        {
            eyesAnimP = &art.playerEyesWalkUpAnimation;
            hairAnimP = &art.playerHairWalkUpAnimation;
            skinAnimP = &art.playerSkinWalkUpAnimation;
            bodyAnimP = &art.playerBodyWalkUpAnimation;
        }
    }
    else if mx > 0
    {
        if walk == 0
        {
            eyesAnimP = &art.playerEyesRestRightAnimation;
            hairAnimP = &art.playerHairRestRightAnimation;
            skinAnimP = &art.playerSkinRestRightAnimation;
            bodyAnimP = &art.playerBodyRestRightAnimation;
        }
        else
        {
            eyesAnimP = &art.playerEyesWalkRightAnimation;
            hairAnimP = &art.playerHairWalkRightAnimation;
            skinAnimP = &art.playerSkinWalkRightAnimation;
            bodyAnimP = &art.playerBodyWalkRightAnimation;
        }
    }
    else if mx < 0
    {
        if walk == 0
        {
            eyesAnimP = &art.playerEyesRestRightAnimation;
            hairAnimP = &art.playerHairRestRightAnimation;
            skinAnimP = &art.playerSkinRestRightAnimation;
            bodyAnimP = &art.playerBodyRestRightAnimation;
        }
        else
        {
            eyesAnimP = &art.playerEyesWalkRightAnimation;
            hairAnimP = &art.playerHairWalkRightAnimation;
            skinAnimP = &art.playerSkinWalkRightAnimation;
            bodyAnimP = &art.playerBodyWalkRightAnimation;
        }
        flipX = true;
    }

    eyesAnim := ^eyesAnimP;
    hairAnim := ^hairAnimP;
    skinAnim := ^skinAnimP;
    bodyAnim := ^bodyAnimP;
    eyesAnim.tick = tick % (eyesAnim.frameTime * eyesAnim.frames.n);
    hairAnim.tick = tick % (hairAnim.frameTime * hairAnim.frames.n);
    skinAnim.tick = tick % (skinAnim.frameTime * skinAnim.frames.n);
    bodyAnim.tick = tick % (bodyAnim.frameTime * bodyAnim.frames.n);

    tl := 0.0;
    tr := 1.0;
    if flipX
    {
        tl = 1.0;
        tr = 0.0;
    }

    eyesColorR := 0.10;
    eyesColorG := 0.34;
    eyesColorB := 0.00;
    hairColorR := 0.62;
    hairColorG := 0.31;
    hairColorB := 0.92;
    skinColorR := 0.98;
    skinColorG := 0.82;
    skinColorB := 0.18;
    bodyColorR := 0.02;
    bodyColorG := 0.61;
    bodyColorB := 0.00;

    renderAnimationAdv(&eyesAnim, player.x, player.y, player.w, player.h, 0.0,
                       tl, tr, 0.0, 1.0, eyesColorR, eyesColorG, eyesColorB, 1.0);
    renderAnimationAdv(&hairAnim, player.x, player.y, player.w, player.h, 0.0,
                       tl, tr, 0.0, 1.0, hairColorR, hairColorG, hairColorB, 1.0);
    renderAnimationAdv(&skinAnim, player.x, player.y, player.w, player.h, 0.0,
                       tl, tr, 0.0, 1.0, skinColorR, skinColorG, skinColorB, 1.0);
    renderAnimationAdv(&bodyAnim, player.x, player.y, player.w, player.h, 0.0,
                       tl, tr, 0.0, 1.0, bodyColorR, bodyColorG, bodyColorB, 1.0);
}
