import "imports.aspel";

Entity :: type struct
{
    x: float32;
    y: float32;

    vw: float32;
    vh: float32;
    pw: float32;
    ph: float32;
    pox: float32;
    poy: float32;

    animation: Animation;

    health: float32;
    maxHealth: float32;
    mana: float32;
    maxMana: float32;

    effects: Effect[];

    userdata: int32;
    tick: delegate void(world: void^, entity: Entity^);
    render: delegate void(entity: Entity^);
};

partialEntityCollideWithTerrain :: func bool(terrain: Terrain^, entity: Entity^,
                                             moveX: float32^, moveY: float32^)
{
    // TODO: improve

    tw := terrain.w;
    th := terrain.h;

    x := entity.x + entity.pox;
    y := entity.y + entity.poy;
    mx := ^moveX;
    my := ^moveY;
    tx := cast(int32) x;
    ty := cast(int32) y;
    t := getTile(terrain, tx, ty);

    nx := x + mx;
    ny := y + my;

    nxo := nx + entity.pw;
    nyo := ny + entity.ph;

    ntx := cast(int32) nx;
    nty := cast(int32) ny;
    ntxo := cast(int32) nxo;
    ntyo := cast(int32) nyo;

    tiy := nty;
    while tiy <= ntyo
    {
        if tiy < 0 || tiy >= th then
            return false;

        tix := ntx;
        while tix <= ntxo
        {
            if tix < 0 || tix >= tw then
                return false;

            nt := getTile(terrain, tix, tiy);
            if t != nt then
                return false;

            tix = tix + 1;
        }

        tiy = tiy + 1;
    }

    return true;
}

entityCollideWithTerrain :: func void(terrain: Terrain^, entity: Entity^,
                                      moveX: float32^, moveY: float32^)
{
    fake: float32 = 0;
    if !partialEntityCollideWithTerrain(terrain, entity, moveX, &fake) then ^moveX = 0;
    if !partialEntityCollideWithTerrain(terrain, entity, &fake, moveY) then ^moveY = 0;
}

pointCollideWithEntity :: func int32(world: World^, x: float32, y: float32, result: Entity^[])
{
    resultCount: int32 = 0;
    if result.n <= resultCount then
        return resultCount;

    i := 0;
    while i < world.entityList.n
    {
        i = i + 1;
        if !world.entityOccupied[i - 1] then continue;
        entity := &world.entityList[i - 1];

        ew := entity.pw;
        eh := entity.ph;
        ehw := ew / 2.0;
        ehh := eh / 2.0;
        ex := entity.x + entity.pox + ehw;
        ey := entity.y + entity.poy + ehh;

        dx := cast(float32) asl.abs(x - ex);
        dy := cast(float32) asl.abs(y - ey);

        if dx > ehw || dy > ehh then continue;

        result[resultCount] = entity;
        resultCount = resultCount + 1;
        if result.n <= resultCount then
            return resultCount;
    }

    return resultCount;
}

// OPTIMIZE: Quad tree, maybe?
projectileCollideWithEntities :: func int32(world: World^, projectile: Projectile^,
                                            result: Entity^[])
{
    resultCount: int32 = 0;
    if result.n <= resultCount then
        return resultCount;

    x := projectile.x;
    y := projectile.y;
    r := projectile.radius;

    i := 0;
    while i < world.entityList.n
    {
        i = i + 1;
        if !world.entityOccupied[i - 1] then continue;
        entity := &world.entityList[i - 1];

        // RECONSIDER: Should we use the visual or physical box?
        ew := entity.vw;
        eh := entity.vh;
        ehw := ew / 2.0;
        ehh := eh / 2.0;
        ex := entity.x + ehw;
        ey := entity.y + ehh;

        dx := cast(float32) asl.abs(x - ex);
        dy := cast(float32) asl.abs(y - ey);

        if dx > (ehw + r) then continue;
        if dy > (ehh + r) then continue;

        if dx <= ehw {}
        else if dy <= ehh {}
        else if ((dx - ehw) * (dx - ehw) + (dy - ehh) * (dy - ehh)) <= r * r {}
        else continue;

        result[resultCount] = entity;
        resultCount = resultCount + 1;
        if result.n <= resultCount then
            return resultCount;
    }

    return resultCount;
}

entityTakeDamage :: func void(world: World^, e: Entity^, dmg: float32)
{
    // TODO: Check resistance, effects...
    e.health = e.health - dmg;
    if e.health <= 0.0
    {
        removeEntityFromWorld(world, e);
    }
}

renderEntity :: func void(e: Entity^)
{
    renderAnimation(&e.animation, e.x, e.y, e.vw, e.vh, 0.0);
}

initPlayer :: func void(player: Entity^, posX: float32, posY: float32)
{
    player.x = posX;
    player.y = posY;
    player.vw = 0.8;
    player.vh = 0.8;
    player.pw = 0.6;
    player.ph = 0.3;
    player.pox = 0.1;
    player.poy = 0.0;
    player.animation = art.invalidAnimation;

    player.health = 322;
    player.maxHealth = 400;
    player.mana = 124;
    player.maxMana = 150;

    player.tick = tickPlayer;
    player.render = renderPlayer;
}

initEye :: func void(eye: Entity^, posX: float32, posY: float32)
{
    random: asl.Random;
    asl.seedRandomTime(&random);
    
    seed: int16 = cast(int16) (asl.randomInt32(&random) & 0xFFFF);
    tick: int16 = 0;

    eye.x = posX;
    eye.y = posY;
    eye.vw = 2.0;
    eye.vh = 2.0;
    eye.pw = 1.8;
    eye.ph = 1.8;
    eye.pox = 0.1;
    eye.poy = 0.1;
    eye.animation = art.eyeAnimation;
    eye.animation.tick = cast(int32)(cast(uint32) asl.randomInt32(&random) %
                                     cast(uint32)(eye.animation.frameTime *
                                                  eye.animation.frames.n));
    eye.animation.slowTick = cast(int32)(cast(uint32) asl.randomInt32(&random) %
                                         cast(uint32)(eye.animation.slowFrameFreq +
                                                      eye.animation.slowFrameTime *
                                                      eye.animation.slowFrames.n));

    eye.health = 100;
    eye.maxHealth = 100;
    eye.mana = 0;
    eye.maxMana = 0;

    eye.userdata = (cast(int32)(seed) << 16) | (cast(int32) tick);
    eye.tick = tickEye;
    eye.render = renderEntity;
}

// CLEANUP: Move these somewhere!
playerHasMoveTarget: bool = false;
playerTargetX: float32;
playerTargetY: float32;

tickPlayer :: func void(worldV: void^, player: Entity^)
{
    world: World^ = cast(World^) worldV;

    moved: bool = false;
    if input.key[INPUT_KEY_LMB]
    {
        playerCX := player.x + player.vw / 2.0;
        playerCY := player.y + player.vh / 2.0;
        movePointX := input.mouseX + playerCX;
        movePointY := input.mouseY + playerCY;

        hit: Entity^[] : [2];
        hitCount: int32 = pointCollideWithEntity(world, movePointX, movePointY, hit);
        playerHit: int32 = 0;

        hitI := 0;
        while hitI < hitCount
        {
            if hit[hitI] == player then
                playerHit = playerHit + 1;
            hitI = hitI + 1;
        }

        hitCount = hitCount - playerHit;

        if hitCount == 0
        {
            moved = true;

            playerHasMoveTarget = true;
            playerTargetX = movePointX;
            playerTargetY = movePointY;
        }
    }

    if playerHasMoveTarget
    {
        deltaX := playerTargetX - (player.x + player.pox + player.pw / 2.0);
        deltaY := playerTargetY - (player.y + player.poy + player.ph / 2.0);
        distance := asl.sqrt(deltaX * deltaX + deltaY * deltaY);

        movementSpeed :: 0.05;
        moveStep := movementSpeed;
        if moveStep > distance
        {
            moveStep = distance;
            playerHasMoveTarget = false;
        }

        angle := asl.atan2(deltaY, deltaX) + asl.to_radians(-90);
        s: float32 = cast(float32) asl.sin(angle);
        c: float32 = cast(float32) asl.cos(angle);
        moveX: float32 = -s * moveStep;
        moveY: float32 =  c * moveStep;

        if !input.key[INPUT_KEY_MACRO4] then
            entityCollideWithTerrain(&world.terrain, player, &moveX, &moveY);
        // TODO: collide with other entitites

        movedDistance := asl.sqrt(moveX * moveX + moveY * moveY);
        if movedDistance < (movementSpeed * 0.3) then
            playerHasMoveTarget = false;

        player.x = player.x + moveX;
        player.y = player.y + moveY;

        visualDX: int32 = 0;
        visualDY: int32 = 0;
        moveA := asl.to_degrees(asl.atan2(moveY, moveX));

        if moveA < -160.0 || moveA > 160.0 || (moveA > -20.0 && moveA < 20.0)
        {
            if moveX < 0.0 then visualDX = -1;
            if moveX > 0.0 then visualDX =  1;
        }
        else
        {
            if moveY < 0.0 then visualDY = -1;
            if moveY > 0.0 then visualDY =  1;
        }

        if !playerHasMoveTarget
        {
            player.userdata = player.userdata & ~0x1;
        }
        else
        {
            player.userdata = (player.userdata & 0xFF00) |
                              ((visualDX + 1) << 4) |
                              ((visualDY + 1) << 1) | 0x1;
        }
    }

    abilityKeys: int64[] : [8];
    abilityKeys[0] = INPUT_KEY_LMB;
    abilityKeys[1] = INPUT_KEY_SHIFT_LMB;
    abilityKeys[2] = INPUT_KEY_RMB;
    abilityKeys[3] = INPUT_KEY_SHIFT_RMB;
    abilityKeys[4] = INPUT_KEY_MACRO1;
    abilityKeys[5] = INPUT_KEY_MACRO2;
    abilityKeys[6] = INPUT_KEY_MACRO3;
    abilityKeys[7] = INPUT_KEY_MACRO4;

    abilityIndex: int64[] : [abilityKeys.n];
    abilityIndex[0] = 0;
    abilityIndex[1] = 0;
    abilityIndex[2] = 1;
    abilityIndex[3] = 1;
    abilityIndex[4] = 2;
    abilityIndex[5] = 3;
    abilityIndex[6] = 4;
    abilityIndex[7] = 5;

    if input.key[INPUT_KEY_F1] && !prevInput.key[INPUT_KEY_F1] then
        applyEffect(player.effects, &effect.healthRegen, 300, 1.0);
    if input.key[INPUT_KEY_F2] && !prevInput.key[INPUT_KEY_F2] then
        applyEffect(player.effects, &effect.manaRegen, 300, 1.0);
    if input.key[INPUT_KEY_F3] && !prevInput.key[INPUT_KEY_F3] then
        applyEffect(player.effects, &effect.poison, 300, 1.0);

    abilityI := 0;
    while abilityI < abilityIndex.n
    {
        key := abilityKeys[abilityI];
        index := abilityIndex[abilityI];

        if !(key == INPUT_KEY_LMB && moved) then
            if input.key[key] && !prevInput.key[key]
            {
                ability := world.playerAbilities[index];
                if ability != null
                {
                    if (key == INPUT_KEY_LMB) || (key == INPUT_KEY_SHIFT_LMB)
                    {
                        playerHasMoveTarget = false;
                        player.userdata = player.userdata & ~0x1;
                    }

                    if ability.checkRequirements(player) then
                        ability.activate(world, player);
                }
            }
        abilityI = abilityI + 1;
    }
}

tickEye :: func void(worldV: void^, eye: Entity^)
{
    world: World^ = cast(World^) worldV;

    // TODO: Diagonal is faster.

    seed: int16 = cast(int16)(eye.userdata >> 16);
    tick: int16 = cast(int16)(eye.userdata & 0xFFFF);
    if tick >= 80
    {
        tick = 0;
        seed = seed + 1;
    }
    tick = tick + 1;
    eye.userdata = (cast(int32)(seed) << 16) | (cast(int32) tick);
    
    random: asl.Random;
    asl.seedRandom(&random, seed);

    movementSpeed :: 0.01;
    mx: float32 = cast(float32) (cast(uint32) asl.randomInt32(&random) % cast(uint32) 3) - 1.0;
    my: float32 = cast(float32) (cast(uint32) asl.randomInt32(&random) % cast(uint32) 3) - 1.0;
    moveX: float32 = mx * movementSpeed;
    moveY: float32 = my * movementSpeed;

    entityCollideWithTerrain(&world.terrain, eye, &moveX, &moveY);
    // TODO: collide with other entitites

    eye.x = eye.x + moveX;
    eye.y = eye.y + moveY;
}

renderPlayer :: func void(player: Entity^)
{
    userdata := player.userdata;
    mx := ((userdata >> 4) & 0x3) - 1;
    my := ((userdata >> 1) & 0x3) - 1;
    walk := userdata & 0x1;
    tick := (userdata & 0xFF00) >> 8;

    player.userdata = (userdata & ~0xFF00) | ((tick + 1) << 8);

    eyesAnimP: Animation^ = &art.invalidAnimation;
    hairAnimP: Animation^ = &art.invalidAnimation;
    skinAnimP: Animation^ = &art.invalidAnimation;
    bodyAnimP: Animation^ = &art.invalidAnimation;
    flipX: bool = false;

    if my < 0
    {
        if walk == 0
        {
            eyesAnimP = &art.playerEyesRestDownAnimation;
            hairAnimP = &art.playerHairRestDownAnimation;
            skinAnimP = &art.playerSkinRestDownAnimation;
            bodyAnimP = &art.playerBodyRestDownAnimation;
        }
        else
        {
            eyesAnimP = &art.playerEyesWalkDownAnimation;
            hairAnimP = &art.playerHairWalkDownAnimation;
            skinAnimP = &art.playerSkinWalkDownAnimation;
            bodyAnimP = &art.playerBodyWalkDownAnimation;
        }
    }
    else if my > 0
    {
        if walk == 0
        {
            eyesAnimP = &art.playerEyesRestUpAnimation;
            hairAnimP = &art.playerHairRestUpAnimation;
            skinAnimP = &art.playerSkinRestUpAnimation;
            bodyAnimP = &art.playerBodyRestUpAnimation;
        }
        else
        {
            eyesAnimP = &art.playerEyesWalkUpAnimation;
            hairAnimP = &art.playerHairWalkUpAnimation;
            skinAnimP = &art.playerSkinWalkUpAnimation;
            bodyAnimP = &art.playerBodyWalkUpAnimation;
        }
    }
    else if mx > 0
    {
        if walk == 0
        {
            eyesAnimP = &art.playerEyesRestRightAnimation;
            hairAnimP = &art.playerHairRestRightAnimation;
            skinAnimP = &art.playerSkinRestRightAnimation;
            bodyAnimP = &art.playerBodyRestRightAnimation;
        }
        else
        {
            eyesAnimP = &art.playerEyesWalkRightAnimation;
            hairAnimP = &art.playerHairWalkRightAnimation;
            skinAnimP = &art.playerSkinWalkRightAnimation;
            bodyAnimP = &art.playerBodyWalkRightAnimation;
        }
    }
    else if mx < 0
    {
        if walk == 0
        {
            eyesAnimP = &art.playerEyesRestRightAnimation;
            hairAnimP = &art.playerHairRestRightAnimation;
            skinAnimP = &art.playerSkinRestRightAnimation;
            bodyAnimP = &art.playerBodyRestRightAnimation;
        }
        else
        {
            eyesAnimP = &art.playerEyesWalkRightAnimation;
            hairAnimP = &art.playerHairWalkRightAnimation;
            skinAnimP = &art.playerSkinWalkRightAnimation;
            bodyAnimP = &art.playerBodyWalkRightAnimation;
        }
        flipX = true;
    }

    eyesAnim := ^eyesAnimP;
    hairAnim := ^hairAnimP;
    skinAnim := ^skinAnimP;
    bodyAnim := ^bodyAnimP;
    eyesAnim.tick = tick % (eyesAnim.frameTime * eyesAnim.frames.n);
    hairAnim.tick = tick % (hairAnim.frameTime * hairAnim.frames.n);
    skinAnim.tick = tick % (skinAnim.frameTime * skinAnim.frames.n);
    bodyAnim.tick = tick % (bodyAnim.frameTime * bodyAnim.frames.n);

    tl := 0.0;
    tr := 1.0;
    if flipX
    {
        tl = 1.0;
        tr = 0.0;
    }

    eyesColorR := 0.10;
    eyesColorG := 0.34;
    eyesColorB := 0.00;
    hairColorR := 0.62;
    hairColorG := 0.31;
    hairColorB := 0.92;
    skinColorR := 0.98;
    skinColorG := 0.82;
    skinColorB := 0.18;
    bodyColorR := 0.02;
    bodyColorG := 0.61;
    bodyColorB := 0.00;

    renderAnimationAdv(&eyesAnim, player.x, player.y, player.vw, player.vh, 0.0,
                       tl, tr, 0.0, 1.0, eyesColorR, eyesColorG, eyesColorB, 1.0);
    renderAnimationAdv(&hairAnim, player.x, player.y, player.vw, player.vh, 0.0,
                       tl, tr, 0.0, 1.0, hairColorR, hairColorG, hairColorB, 1.0);
    renderAnimationAdv(&skinAnim, player.x, player.y, player.vw, player.vh, 0.0,
                       tl, tr, 0.0, 1.0, skinColorR, skinColorG, skinColorB, 1.0);
    renderAnimationAdv(&bodyAnim, player.x, player.y, player.vw, player.vh, 0.0,
                       tl, tr, 0.0, 1.0, bodyColorR, bodyColorG, bodyColorB, 1.0);
}
