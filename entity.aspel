import "imports.aspel";

Entity :: type struct
{
    x: float32;
    y: float32;

    vw: float32;
    vh: float32;
    pw: float32;
    ph: float32;
    pox: float32;
    poy: float32;

    animation: Animation;

    health: float32;
    maxHealth: float32;
    mana: float32;
    maxMana: float32;

    effects: Effect[];

    userdata: int32;
    tick: delegate void(world: World^, entity: Entity^);
    render: delegate void(entity: Entity^);
    onDeath: delegate void(entitY: Entity^);
};

partialEntityCollideWithTerrain :: func bool(terrain: Terrain^, entity: Entity^,
                                             moveX: float32^, moveY: float32^)
{
    // TODO: improve

    tw := terrain.w;
    th := terrain.h;

    x := entity.x + entity.pox;
    y := entity.y + entity.poy;
    mx := ^moveX;
    my := ^moveY;
    tx := cast(int32) x;
    ty := cast(int32) y;
    t := getTile(terrain, tx, ty);

    nx := x + mx;
    ny := y + my;

    nxo := nx + entity.pw;
    nyo := ny + entity.ph;

    ntx := cast(int32) nx;
    nty := cast(int32) ny;
    ntxo := cast(int32) nxo;
    ntyo := cast(int32) nyo;

    tiy := nty;
    while tiy <= ntyo
    {
        if tiy < 0 || tiy >= th then
            return false;

        tix := ntx;
        while tix <= ntxo
        {
            if tix < 0 || tix >= tw then
                return false;

            nt := getTile(terrain, tix, tiy);
            if t != nt then
                return false;

            tix = tix + 1;
        }

        tiy = tiy + 1;
    }

    return true;
}

entityCollideWithTerrain :: func void(terrain: Terrain^, entity: Entity^,
                                      moveX: float32^, moveY: float32^)
{
    fake: float32 = 0;
    if !partialEntityCollideWithTerrain(terrain, entity, moveX, &fake) then ^moveX = 0;
    if !partialEntityCollideWithTerrain(terrain, entity, &fake, moveY) then ^moveY = 0;
}

pointCollideWithEntity :: func int32(world: World^, x: float32, y: float32, result: Entity^[])
{
    resultCount: int32 = 0;
    if result.n <= resultCount then
        return resultCount;

    i := 0;
    while i < world.entityList.n
    {
        i = i + 1;
        if !world.entityOccupied[i - 1] then continue;
        entity := &world.entityList[i - 1];

        ew := entity.pw;
        eh := entity.ph;
        ehw := ew / 2.0;
        ehh := eh / 2.0;
        ex := entity.x + entity.pox + ehw;
        ey := entity.y + entity.poy + ehh;

        dx := cast(float32) asl.abs(x - ex);
        dy := cast(float32) asl.abs(y - ey);

        if dx > ehw || dy > ehh then continue;

        result[resultCount] = entity;
        resultCount = resultCount + 1;
        if result.n <= resultCount then
            return resultCount;
    }

    return resultCount;
}

// OPTIMIZE: Quad tree, maybe?
projectileCollideWithEntities :: func int32(world: World^, projectile: Projectile^,
                                            result: Entity^[])
{
    resultCount: int32 = 0;
    if result.n <= resultCount then
        return resultCount;

    x := projectile.x;
    y := projectile.y;
    r := projectile.radius;

    i := 0;
    while i < world.entityList.n
    {
        i = i + 1;
        if !world.entityOccupied[i - 1] then continue;
        entity := &world.entityList[i - 1];

        // RECONSIDER: Should we use the visual or physical box?
        ew := entity.vw;
        eh := entity.vh;
        ehw := ew / 2.0;
        ehh := eh / 2.0;
        ex := entity.x + ehw;
        ey := entity.y + ehh;

        dx := cast(float32) asl.abs(x - ex);
        dy := cast(float32) asl.abs(y - ey);

        if dx > (ehw + r) then continue;
        if dy > (ehh + r) then continue;

        if dx <= ehw {}
        else if dy <= ehh {}
        else if ((dx - ehw) * (dx - ehw) + (dy - ehh) * (dy - ehh)) <= r * r {}
        else continue;

        result[resultCount] = entity;
        resultCount = resultCount + 1;
        if result.n <= resultCount then
            return resultCount;
    }

    return resultCount;
}

entityTakeDamage :: func void(world: World^, e: Entity^, dmg: float32)
{
    // TODO: Check resistance, effects...
    e.health = e.health - dmg;
    if e.health <= 0.0
    {
        e.onDeath(e);
        removeEntityFromWorld(world, e);
    }
}

renderEntity :: func void(e: Entity^)
{
    renderAnimation(&e.animation, e.x, e.y, e.vw, e.vh, 0.0);
}

defaultOnDeath :: func void(e: Entity^)
{

}
