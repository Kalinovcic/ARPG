
Ability :: type struct
{
    checkRequirements: delegate bool(e: Entity^);
    activate: delegate void(world: World^, e: Entity^);

    icon: Animation;
};

spendMana :: func void(e: Entity^, mana: float32)
{
    e.mana = e.mana - mana;
    if e.mana < 0.0 then
        e.mana = 0.0;
}

manaRequirement :: func bool(e: Entity^, mana: float32)
{
    return e.mana >= mana;
}

/* FIREBALL */

FIREBALL_MANA: float32 : 2.0;
FIREBALL_DAMAGE: float32 : 8.0;
FIREBALL_SPEED: float32 : 0.05;
FIREBALL_RADIUS: float32 : 0.15;
FIREBALL_LIFETIME: int32 : 400;

namespace ability
{
    fireball: Ability;
}

fireballRequirements :: func bool(e: Entity^)
{
    return manaRequirement(e, FIREBALL_MANA);
}

fireballActivate :: func void(world: World^, e: Entity^)
{
    spendMana(e, FIREBALL_MANA);

    // TODO: make this work for enemies, they need to specify what they're targeting.
    mouseAngle := asl.atan2(-input.mouseX, input.mouseY);

    fireball := addProjectileToWorld(world);
    fireball.x = e.x + e.vw / 2.0 - FIREBALL_RADIUS;
    fireball.y = e.y + e.vh / 2.0 - FIREBALL_RADIUS;
    fireball.z = 0;

    fireball.a = asl.to_degrees(mouseAngle);
    fireball.speed = FIREBALL_SPEED;
    fireball.damage = FIREBALL_DAMAGE;
    fireball.owner = e;

    fireball.radius = FIREBALL_RADIUS;
    fireball.lifetime = FIREBALL_LIFETIME;
    fireball.animation = art.projectile.fireball;

    random: asl.Random;
    asl.seedRandomTime(&random);
    randomIndex := cast(uint32) asl.randomInt32(&random);
    spriteIndex := randomIndex % art.particle.fireballTrail.n;
    sprite := art.particle.fireballTrail[spriteIndex];
    fireball.particleSprite = sprite;
}

/* EYEBALL */

EYEBALL_MANA: float32 : 30.0;
EYEBALL_DAMAGE: float32 : 50.0;
EYEBALL_SPEED: float32 : 0.05;
EYEBALL_RADIUS: float32 : 0.3;
EYEBALL_LIFETIME: int32 : 400;

namespace ability
{
    eyeball: Ability;
}

eyeballRequirements :: func bool(e: Entity^)
{
    return manaRequirement(e, EYEBALL_MANA);
}

eyeballActivate :: func void(world: World^, e: Entity^)
{
    spendMana(e, EYEBALL_MANA);

    // TODO: make this work for enemies, they need to specify what they're targeting.
    mouseAngle := asl.atan2(-input.mouseX, input.mouseY);

    eyeball := addProjectileToWorld(world);
    eyeball.x = e.x + e.vw / 2.0 - EYEBALL_RADIUS;
    eyeball.y = e.y + e.vh / 2.0 - EYEBALL_RADIUS;
    eyeball.z = 0;

    eyeball.a = asl.to_degrees(mouseAngle);
    eyeball.speed = EYEBALL_SPEED;
    eyeball.damage = EYEBALL_DAMAGE;
    eyeball.owner = e;

    eyeball.radius = EYEBALL_RADIUS;
    eyeball.lifetime = EYEBALL_LIFETIME;
    eyeball.animation = art.projectile.eyeball;

    random: asl.Random;
    asl.seedRandomTime(&random);
    randomIndex := cast(uint32) asl.randomInt32(&random);
    spriteIndex := randomIndex % art.particle.eyeballTrail.n;
    sprite := art.particle.eyeballTrail[spriteIndex];
    eyeball.particleSprite = sprite;
}

initAbilities :: func void()
{
    ability.fireball.checkRequirements = fireballRequirements;
    ability.fireball.activate = fireballActivate;
    ability.fireball.icon = art.projectile.fireball;

    ability.eyeball.checkRequirements = eyeballRequirements;
    ability.eyeball.activate = eyeballActivate;
    ability.eyeball.icon = art.projectile.eyeball;
}
